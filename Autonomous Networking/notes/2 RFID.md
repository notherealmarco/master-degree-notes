Radio-frequency identification (RFID) is a technology that uses radio waves to communicate wirelessly. An RFID system consists of two main components:
- **Tags:** small, inexpensive, and long-lasting devices that are attached to objects to be identified. They store a unique identifier, typically 96 bits long, and consist of an antenna integrated onto a microchip. RFID tags are battery-free, passive devices that harvest power from radio frequency signals. They reflect the signal generated by the reader to transmit their unique ID.
- **Readers:** These are more powerful devices that query tags to retrieve their IDs.

#### MAC issues
- large number of passive tags
- tags cannot transmit transmit spontaneously:
	- reader queries tags
	- tags respond with their ID by back-scattering the received signal
	- two or more simultaneous tag responses cause collision
	- tags cannot ear each other (no carrier sense, no collision detection)
	- channel access must be arbitrated by the reader

## Mac protocols
To identify tags in a RFID system, several MAC protocols have been proposed

**Sequential protocols**
aim at singulating tag transmissions
- **Tree based**
	- Binary Splitting
	- Query Tree
	- Variations (Query Tree Improved)
- **Aloha based**
	- Framed Slotted Alhoa
	- EPC Gen Standard
	- Tree Slotted Alhoa
	- Variations (BSTSA)

**Concurrent protocols**
not covered in the course

#### Binary Splitting
- BS recursively splits answering tags into two subgroups until obtaining singletag groups.
- Tags answer to reader’s queries according to the generation of a binary random number

-  Suppose we have a set of tags to identify
 - Each tag has a counter initially set to zero
-  The tags with the counter = 0 reply to the reader query
 - The reader sends a query
 - All tags reply → collision
 - Each tag generates a random binary number (0,1) and sums it to the counter
-  The process repeats
	 - The reader sends a query
	 - All tags with C=0 replies
	 - If collision → each replying tag generates a random binary number and sums it to its counter
	 - Each other tag (silent) → C=C+1
	 - If none or one tag replies → all tags: counter = counter - 1
#### Query Tree
- QT queries tags according to the binary structure of their ID

- The reader interrogates tags by sending them a string, and only those tags whose IDs have a **prefix** matching that string respond to the query
- At the beginning, the reader queries all tags: this is implemented by including a **NULL** string in the query
- If a collision occurs, then the string length is **increased by one bit** until the collision is solved and a tag is identified
- The reader then starts a new query with a different string. In particular, if tag identification occurs with a string q0 the reader will query for string **q1**

#### Performances
In case of uniform ID distribution, the tree induced by QT is analogous to the tree induced by BS, this is because a set of uniformly distributed tags splits approximately in equal parts, like in the Bs protocol.
![[Pasted image 20240928134852.png]]
→ QT and BS protocols have the same estimated performance!
##### Measuring the performance
- we want to know how fast a protocol is to collect all tags ID (each tag needs to reply)
- if we have n tags, then the protocol will end when all n tags have responded singularly
-  system efficiency: $SE = \frac{n}{q}$ (n  = single responses, q = total number of queries)
###### Performance of Binary Splitting
- to evaluate efficiency (SE) we need to estimate the total number of queries (#Q) that we call $BS_{tot}(n)$
- to evaluate the total number of queries we estimate the total number of nodes in a BS tree
- at each queries tags split into two sets
- we recursively count the number of nodes in the tree
	![[Pasted image 20240928140723.png]]
- we estimate the total number of queries $BS_{tot}(n)$ to identify n tags as $$BS_{tot}(n)=\begin{cases}1,n\le1\\ 1+\sum_{k=0}^{n}\binom{n}{k}\left(\frac12\right)^{k}\left(1-\frac12\right)^{n-k}\left(BS_{tot}\left(k\right)+BS_{tot}\left(n-k\right)\right),n>1\end{cases}$$
- for large values of n, we get $SE_{BS}=0.38$, which means that only 38% of queries are successful!
- **the efficiency is low!**

#### Aloha principle
- Time is slotted. Slot duration is equal to the tag’s ID transmission time
- Slots are grouped into frames
- Each tag randomly picks a slot to respond

#### Frame slotted Aloha
- when a reader issues a start of frame, it includes the number of slots in a frame
- the tags then randomly pick a slot in which to reply
- collisions occur if two or more tags pick the same slot
- the process repeats itself until all tags are identified
- once a tag is identified, it no longer responds to the start of frame
![[Pasted image 20240928143319.png]]
In the example above, we have 6 slots, 3 collision and 3 identified tags.
- system efficiency is equal to $\frac{\#identifications}{\#slots} = 50\%$
- in general, best performance is achieved when the number of slots in a frame is equal to the number of tags to be identified

#### EPC Gen 2 class 1
- Based on Frame slotted Aloha
- adapts frame length according to the number of collisions and empty slots
- specifies the **transmission time model**, that allow us to estimate a temporale evaluation of protocol performance

##### Transmission time model
![[Pasted image 20240928155313.png]]
- R1: tag reaction time
- R2: reader reaction time
- RX_threshold: time at which the reader should receive the first bit of tag transmission

The key aspect of transmission time model stands in observing that idle responses (no response) last less than identification or colliding responses

#### Analytical model
Each tag randomly selects a slot (balls and bins model)
![[Pasted image 20240928160334.png]]
- n tags randomly select the slot to answer among N slots
- the probability that r tags answer in the same slot is given by the binomial distribution
- the number of slots with exactly r tags (probabilità che r tag scelgano lo stesso slot) is given by: $$s\left(r\right)=N\binom{n}{r}\left(\frac{1}{N}\right)^{r}\left(1-\frac{1}{N}\right)^{n-r}$$
##### Time system efficiency
- Let $R_{ident}, R_{call}, R_{idle}$ be the number of identifications, collisions and idle rounds during the identification process
- $R_{idle}=N(1-\frac{1}{N})^n$
- $R_{ident}=n(1-\frac{1}{N})^{n-1}$
- $R_{coll}=N-R_{idle}-R_{ident}$
- system efficiency = $R_{ident}/(R_{idle}+R_{ident}+R_{coll})$
- will be **36%** if rounds have the same duration

As stated before, we can make idle rounds last less. Let's suppose they last a $\beta$ fraction of the identification/collision round time:
$$Time\_SE=\frac{R_{ident}}{\beta R_{idle}+R_{ident}+R_{coll}}=\frac{n\left(1-\frac{1}{N}\right)^{n-1}}{\left(\beta-1\right)N\left(1-\frac{1}{N}\right)^{n}+N}$$![[Pasted image 20240928164839.png]]
**40% of time is wasted in idle and collisions slots!** Can we reduce this time?

### Tree slotted Aloha
- slots are executed following a tree
- a new child frame is issued for each collision slot: only tags replying to the same slot participate into the new slot

![[Pasted image 20240928165943.png]]
[Learn more](https://www.researchgate.net/figure/An-example-of-Tree-Slotted-Aloha-TSA_fig21_326759775)

- To estimate TSA performance we again count the number of nodes in the TSA tree
$$TSA_{tot}(n)=\begin{cases}1,n=1\\ n+n\sum_{k=2}^{n}\binom{n}{k}\left(\frac{1}{n}\right)^{k}\left(1-\frac{1}{n}\right)^{n-k}TSA_{tot}\left(k\right),n>1\end{cases}$$
- per valori grandi di n, l'efficienza è 0.43
![[Pasted image 20240928175441.png]]

#### TSA and FSA: main issues
Often the number of tags in the system **is not known!**
- how can we estimate the frame size?
- any time TSA issues a new frame it has to estimate the number of tags participating into that frame
- and the initial frame? How many tags are in the environment?

##### Estimating tag population for intermediate frames
- The number of tags to be identified is not known
- The initial frame size is set to a predefined value (i.e., 128)
- The size of the following frames is estimated $$tags\_per\_collision\_slot=\frac{(estimated\_total\_num\_of\_tags) - (identified\_tags)}{collision\_slots}$$
- We know number of identified tags and number of collision slots, but **we don't know** the total number of tags! :/

-  The total number of tags is estimated according to the outcome of the previous frame (based on Chebyshevʼs inequality)
	 ![[Pasted image 20240928181304.png]]

Given N and a possible value of n, the expected number of slots with r tags is estimated as:
![[Pasted image 20240928181424.png]]

##### Inaccuracy of tag estimation for large networks
- The estimator does not capture the possibly high variance of the number of tags
-  The minimum distance is computed over n ranging in $[c_1 + 2c_k, 2(c1 + 2c_k)]$
- The upper bound $2(c1 + 2c_k)$ is not adequate for network composed of thousands of nodes
	![[Pasted image 20240928183123.png]]
Let's try to find a better upper bound!
A solution can be the BSTSA protocol.

#### Binary Splitting Tree Slotted Aloha
- Basic principle: any large group of elements randomly split into two groups of almost the same size
- BSTSA: Combination of BS and TSA
	- BS is used to divide tags into groups whose size can be easily estimated
	- TSA is used to identify tags
![[Pasted image 20240928193208.png]]

L'idea è che facendo binary split fino ad avere un gruppo con un solo tag (come in figura), poi posso finalmente stimare la dimensione degli altri gruppi, in questo modo posso scegliere un valore di N (numero di slot) adeguato per identificare ogni gruppo con TSA.

##### Performances
- BS performace up to the last split
- TSA performance for each group
- Optimal frame tuning is considered (overestimating frame size to allow for more idle slots than collision slots)
![[Pasted image 20240928193303.png]]![[Pasted image 20240928193321.png]]
